<!doctype book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
<!entity libglade-glade-build SYSTEM "sgml/glade-build.sgml">
<!entity libglade-glade-parser SYSTEM "sgml/glade-parser.sgml">
<!entity libglade-glade-xml SYSTEM "sgml/glade-xml.sgml">
<!entity libglade-glade SYSTEM "sgml/glade.sgml">
]>

<book id="libglade">
  <bookinfo>
    <title>Libglade Reference Manual</title>
    <authorgroup>
      <author>
	<firstname>James</firstname>
	<surname>Henstridge</surname>
	<affiliation>
	  <address>
	    <email>james@daa.com.au</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>

    <copyright>
      <year>1999-2002</year>
      <holder>James Henstridge</holder>
    </copyright>

    <legalnotice>
      <para>Permission is granted to copy, distribute and/or modify
      this document under the terms of the <citetitle>GNU Free
      Documentation License</citetitle>, Version 1.1 or any later
      version published by the Free Software Foundation with no
      Invariant Sections, no Front-Cover Texts, and no Back-Cover
      Texts. You may obtain a copy of the <citetitle>GNU Free
      Documentation License</citetitle> from the Free Software
      Foundation by visiting <ulink type="http"
      url="http://www.fsf.org">their Web site</ulink> or by writing
      to: Free Software Foundation, Inc., 59 Temple Place - Suite 330,
      Boston, MA 02111-1307, USA.</para>

      <para>Many of the names used by companies to distinguish their
      products and services are claimed as trademarks. Where those
      names appear in any GNOME documentation, and those trademarks
      are made aware to the members of the GNOME Documentation
      Project, the names have been printed in caps or initial
      caps.</para>
    </legalnotice>

    <abstract>
      <para>This manual documents the interfaces of the libglade
      library and has some short notes to help get you up to speed
      with using the library.</para>
    </abstract>
  </bookinfo>

  <chapter id="libglade-notes">
    <title>Libglade Programming Notes</title>

    <para>Libglade is an alternative to using Glade's code generation.
    Instead of generating code from the XML interface description,
    libglade loads and parses the description at runtime.  It also
    provides functions that can be used to connect signal handlers to
    parts of the interface.</para>

    <para>In this way, it allows you to separate your program code
    from the interface code.  In fact, if you use the
    glade_xml_signal_autoconnect() function, the GUI code could be as
    simple as the <filename>test-libglade.c</filename> example that
    comes with libglade.  Of course, you would also add your own
    signal handlers to the code.  Note that the signals are connected
    the same way as if you had hand coded the interface.  There is no
    extra overhead to user interfaces constructed by libglade (after
    the initial generating of course, and this is not much of an
    overhead) when compared to a hand crafted interface.</para>

    <sect1 id=libglade-basics>
      <title>Libglade Programming Basics</title>

      <para>Your basic libglade program will look something like this:</para>
<programlisting><![CDATA[
#include <gtk/gtk.h>
#include <glade/glade.h>

void some_signal_handler_func(GtkWidget *widget, gpointer user_data) {
  /* do something useful here */
}

int main(int argc, char *argv[]) {
    GladeXML *xml;

    gtk_init(&argc, &argv);

    /* load the interface */
    xml = glade_xml_new("filename.glade", NULL, NULL);

    /* connect the signals in the interface */
    glade_xml_signal_autoconnect(xml);

    /* start the event loop */
    gtk_main();

    return 0;
}
]]></programlisting>

      <para>This will create the interface from the file
      <filename>filename.glade</filename>, then connect all the
      signals in the interface.  The automatic signal connection is
      done by looking up function names in the global symbol table
      using gmodule.  This means that the interface file can use
      standard GTK functions such as
      <function>gtk_widget_show</function>, or
      <function>gtk_main_quit</function>, or others in the interface
      and not have to write any code to connect the signals.</para>

      <para>The <function>some_signal_handler_func</function> function
      is not referenced anywhere in the program explicitely, but if
      any signals are defined in the interface description that use
      "some_signal_handler_func" as the handler name, then this
      function will automatically be connected.  Note that the
      function can not be static, since we require it to apear in the
      symbol table.  Here is an example of the XML that would cause
      <function>some_signal_handler_func</function> to be
      connected:</para>

<programlisting><![CDATA[
<widget class="GtkWindow" id="MainWindow">
  <property name="visible">yes</property>
  <signal name="destroy" handler="some_signal_handler_func" />
  ...
</widget>
]]></programlisting>

      <note>
	<para>If you wish to autoconnect handlers defined in the main
	executable (not a shared library), you will need to pass a
	linker flag to export the executable's symbols for dynamic
	linking.  This flag is platform specific, but libtool can take
	care of this for you.  Just add
	<parameter>-export-dynamic</parameter> argument to your link
	flags, and libtool will convert it to the correct
	format.</para>

	<para>Many people did not see this problem on GNU/Linux with
	GTK+ 1.2, because the <command>gtk-config</command> script
	adds the correct flag on that platform.  Such programs would
	sometimes break when run on alternative platforms.</para>
      </note>

      <para>To compile the program, we would use the following:</para>
<programlisting>
cc -o testprogram testprogram.c `pkg-config --cflags --libs libglade-2.0`
</programlisting>

      <para>The <command>pkg-config</command> program is used to
      deduce the compiler and link flags necessary to compile various
      modules.  If you are using automake or autoconf, you probably
      want to use the PKG_CHECK_MODULES macro.  This can be used to
      check for the presence of a collection of a number of packages,
      and set some shell variables:</para>

<programlisting>
PKG_CHECK_MODULES(MYPROG, libglade-2.0 libgnomeui-2.0 >= 1.110.0)
AC_SUBST(MYPROG_CFLAGS)
AC_SUBST(MYPROG_LIBS)
</programlisting>

    </sect1>

    <sect1 id=libglade-modules>
      <title>Libglade Modules</title>
      
      <para>Libglade can be extended to support widget libraries built
      on top of GTK+.  These modules are loaded dynamically at
      runtime.  These modules are loaded when
      <sgmltag>&lt;requires&gt;</sgmltag> elements are found in the
      glade file.</para>

      <para>Currently there are libglade module support for
      libbonoboui libgnomecanvas and libgnomeui.  Note that libglade
      can also handle widgets that implement the properties interfaces
      with no extra code.</para>

      <para>While no additional libglade initialisation is required to
      use a module, however, the underlying library might need
      initialisation.  For instance, to use libgnomeui widgets from
      libglade, you <emphasis>must</emphasis> call
      <function>gnome_program_init</function> beforehand.</para>

    </sect1>

    <sect1 id="libglade-i18n">
      <title>Internationalisation with Libglade</title>

      <para>Glade files mark properties for translation with the
      <parameter>translatable</parameter> property of the
      <sgmltag>&lt;property&gt;</sgmltag> element:</para>

<programlisting><![CDATA[
<widget class="GtkLabel" id="label1">
  <property name="label" translatable="yes">Foo</property>
  ...
</widget>
]]></programlisting>

      <para>Libglade will translate marked properties using the
      translation domain specified in the
      <function>glade_xml_new()</function> (or the default domain if
      <constant>NULL</constant>).</para>

      <para>To add the strings found in a glade file to your
      translation catalog template through the use of
      <command>intltool</command>. (XXXX - does this actually work
      yet?).</para>

    </sect1>

    <sect1 id=libglade-extending>
      <title>Extending Libglade</title>

      <para>In some cases, libglade may not provide support for the
      widgets you want to use, or you may want to insert a bit of hand
      coded interface into the larger libglade generated
      interface.  Libglade provides support for doing this.</para>

      <para>If you are only need a few custom widgets (eg. a word
      processor may have a custom widget for the document editing
      area), the simplest choice is probably Glade's custom widget.
      It allows you to specify a custom function that will be used to
      create the widget.  The signature of the function is as
      follows:</para>
<programlisting>
GtkWidget *custom_func(gchar *widget_name, gchar *string1, gchar *string2,
                       gint int1, gint int2);
</programlisting>
      <para>When calling this function, widget_name is the name of the
      widget given in the XML file, and string1, string2, int1 and
      int2 are arbitrary constants whose values also come from the XML
      file.  Libglade supports the custom widget using gmodule.  For
      most cases, this is sufficient.</para>

      <para>If you wish to get libglade to recognise new widget types,
      you will need to do a bit more work.  You will need to write a
      function that will create the widget from a node in the XML tree
      (the function need not worry about standard options like whether
      the widget is visible or not, or how it is added to its parent).
      If the widget is also a container, you will need to specify a
      child building function (which is also responsible for adding
      the widgets to container).  If the container uses the standard
      <function>gtk_container_add</function> interface, you can use
      the <function>glade_standard_build_children</function> function
      that is provided by libglade.</para>

      <para>For a more extensive example of registering new widget
      types and build functions, see the files
      <filename>glade/glade-gtk.c</filename> or
      <filename>glade/glade-gnome.c</filename> in the libglade
      package.  For more information on the exact API's used to
      register new widget types with libglade, see the <link
      linkend="libglade-Libglade-Build">Libglade Build</link> section
      of this manual.</para>

    </sect1>

    <sect1 id=libglade-embedding>
      <title>Embedding Libglade Interfaces</title>

      <para>Sometimes you will only want to use libglade for a small
      part of your program.  If it is just for some dialogs, this is
      easy -- you just generate the dialogs from the interface files
      when needed (note that libglade caches the XML parse tree
      between calls to <function>glade_xml_new</function>, so you will
      not suffer the performance hit of parsing a particular XML file
      more than once).  On the other hand, you may want to use
      libglade to generate just the menubar or just a notebook for a
      dialog or something.  Libglade allows this as well.</para>

      <para>Libglade allows you to build only part of the interface if
      you want to.  The second argument to
      <function>glade_xml_new</function> specifies the name of the
      base widget to build the interface from.  This way we can limit
      the widgets that are constructed by libglade.</para>

      <para>For the menubar example, we would create a dummy window in
      Glade, and insert a menubar widget into the window.  We would
      then name the menubar in glade ("menubar" isn't a bad name :),
      and customise it as much as we want.  Now in the program, we can
      use the following code:</para>
<programlisting>
GladeXML *xml;
GtkWidget *menubar;

xml = glade_xml_new("some-interface-file", "menubar");
glade_xml_signal_autoconnect(xml);
menubar = glade_xml_get_widget(xml, "menubar");
/* do whatever we want to with the menubar */
</programlisting>
      <para>From here, we can do what ever we want with the menubar
      widget.  The dummy window we created in Glade is never created,
      so does not affect the program.  You can also use similar code
      to only build a single dialog from a file that contains many
      dialogs.</para>

      <para>One thing to note -- if you don't want a widget to be
      displayed as soon as it is built with
      <function>glade_xml_new</function>, you should turn off the
      visible flag on that widget in Glade.  This is the correct
      solution to the problem (putting a hack into libglade so that it
      never shows the toplevel windows is not The Right Thing).</para>

    </sect1>
  </chapter>

  <chapter id="libglade-lib">
    <title>Libglade Library Reference</title>

    <para>This section contains the API reference for libglade.  All
    the public interfaces are documented here.</para>

    &libglade-glade;
    &libglade-glade-xml;
    &libglade-glade-parser;
    &libglade-glade-build;
  </chapter>
  <chapter id="libglade-dtd">
    <title>Glade 2.0 DTD</title>

    <para>The following DTD defines the format used as input for
    libglade:</para>

<programlisting><![CDATA[
<!-- proposed DTD for new glade format -->

<!ELEMENT glade-interface (requires*, widget*) >
<!ATTLIST glade-interface
  xmlns CDATA #FIXED 'http://glade.gnome.org/glade-2.0.dtd' >

<!ELEMENT requires EMPTY >
<!ATTLIST requires
  lib CDATA #REQUIRED >

<!ELEMENT widget (property*, accessibility?, signal*, accelerator*, child*) >
<!ATTLIST widget
  class CDATA #REQUIRED
  id ID #REQUIRED >

<!ELEMENT property (#PCDATA) >
<!-- type is an optional tag, and should be the string name of the
     GType for the property -->
<!-- translatable specifies whether the property should be translated
     before use. -->
<!ATTLIST property
  name CDATA #REQUIRED
  type CDATA #IMPLIED
  translatable (yes|no) 'no' >

<!ELEMENT accessibility (property+) >

<!ELEMENT signal EMPTY >
<!ATTLIST signal
  name CDATA #REQUIRED
  handler CDATA #REQUIRED
  after (yes|no) 'no'
  object IDREF #IMPLIED >

<!ELEMENT accelerator EMPTY >
<!ATTLIST accelerator
  key CDATA #REQUIRED
  modifiers CDATA #REQUIRED
  signal CDATA #REQUIRED >

<!ELEMENT child (widget, packing?) >
<!-- composite children should not have any properties set on them.
     (Composite children are things like the scrollbars in a
     GtkScrolledWindow, or the vbox in a GtkDialog). -->
<!ATTLIST child
  internal-child CDATA #IMPLIED >

<!ELEMENT packing (property+) >
]]></programlisting>

  </chapter>

</book>
